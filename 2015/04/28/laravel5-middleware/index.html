<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Laravel5新特性 - MiddleWare · xbhub</title><meta name="description" content="在程序开发阶段，往往需要对一段业务代码在权限验证和业务条件需求方面进行限制。laravel之前的解决方案是使用filter，在业务路由之间对每一个路由或者路由组进行filter限制达到业务过滤的作用，在我之前的一个项目中，我还利用了filter完成了网站的缓存预处理和业务逻辑验证。
Filter在laravel4中的使用可以在路由中，或者是在控制器中配置，但我更喜欢在路由文件中配置。虽然Filter已经能够完成一套完整的业务逻辑，但Filter中的规则却未能很好的封装。比如文章发布系统：发布之前我们要对编辑进行编辑level认证和频道权限认证(EditorAuthFilter)，发布完成之后要触发事件给总编辑发送邮件审核文章(SendCheckMailFilter)，如果使用之前的Filter，我们在每次需要发布文章的业务逻辑处都需要添加BeforeFilter为EditorAuthFilter，AfterFilter为SendCheckMailFilter，所以更友好的方式是将一整套的Filter机制封装起来处理。当然，大家会注意到，其实Filter并不是只干了过滤器的作用，它主要在业务中间层做了一系列的业务逻辑操作，所以这也是我认为Laravel5提出的MiddleWare代替了之前的Filter。
&lt;h2 id=&quot;MiddleWare_u5230_"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="http://weibo.com/jorycn" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://github.com/jorycn" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Laravel5新特性 - MiddleWare</h1><div class="post-meta"><div class="post-time">2015年4月28日</div></div><div class="post-content"><p>在程序开发阶段，往往需要对一段业务代码在权限验证和业务条件需求方面进行限制。laravel之前的解决方案是使用filter，在业务路由之间对每一个路由或者路由组进行filter限制达到业务过滤的作用，在我之前的一个项目中，我还利用了filter完成了网站的缓存预处理和业务逻辑验证。</p>
<p>Filter在laravel4中的使用可以在路由中，或者是在控制器中配置，但我更喜欢在路由文件中配置。虽然Filter已经能够完成一套完整的业务逻辑，但Filter中的规则却未能很好的封装。比如文章发布系统：发布之前我们要对编辑进行编辑level认证和频道权限认证(EditorAuthFilter)，发布完成之后要触发事件给总编辑发送邮件审核文章(SendCheckMailFilter)，如果使用之前的Filter，我们在每次需要发布文章的业务逻辑处都需要添加BeforeFilter为EditorAuthFilter，AfterFilter为SendCheckMailFilter，所以更友好的方式是将一整套的Filter机制封装起来处理。当然，大家会注意到，其实Filter并不是只干了过滤器的作用，它主要在业务中间层做了一系列的业务逻辑操作，所以这也是我认为Laravel5提出的MiddleWare代替了之前的Filter。</p>
<h2 id="MiddleWare_u5230_u5E95_u662F_u4EC0_u4E48"><a href="#MiddleWare_u5230_u5E95_u662F_u4EC0_u4E48" class="headerlink" title="MiddleWare到底是什么"></a>MiddleWare到底是什么</h2><p>下面是<a href="http://stackphp.com/" target="_blank" rel="external">StackPHP</a>的MiddleWare的概念图：<br><img src="http://stackphp.com/img/onion.png" alt="StackPHP MiddleWare"></p>
<p>简单的理解就是，MiddleWare就是在请求发送之后到应用程序响应之前所完成的一系列业务逻辑。<br>ok，那么在Laravel5中我们该怎样使用middleware呢？</p>
<h2 id="MiddleWare_u7684_u4F7F_u7528"><a href="#MiddleWare_u7684_u4F7F_u7528" class="headerlink" title="MiddleWare的使用"></a>MiddleWare的使用</h2><p>命名生成MiddleWare:</p>
<div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">php artisan make:middleware MyMiddleware</pre><br></div><br></div><br>该条命令将会生成以下中间件：<br><div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">&lt;?php namespace App\Http\Middleware;<br><br>use Closure;<br>use Illuminate\Contracts\Routing\Middleware;<br><br>class MyMiddleware implements Middleware {<br><br>/<strong><br><em> Handle an incoming request.
</em><br><em> @param \Illuminate\Http\Request $request
        </em> @param  \Closure  $next<br><em> @return mixed
</em>/<br>public function handle($request, Closure $next)<br>{<br>//<br>}<br><br>}</strong></pre><br></div><br></div><br>正如大家所见，处理中间件的函数正是handle函数，它有两个参数一个是需要处理的request请求，一个是Closure（匿名函数）用来处理通过中间件下一步需要执行的函数。<br>使用中间件还可以用来做端口控制：<br><div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">&lt;?php namespace App\Http\Middleware;<br><br>use Closure;<br>use Illuminate\Contracts\Routing\Middleware;<br><br>class MyMiddleware implements Middleware {<br><br>/<br><em> Handle an incoming request.
</em><br><em> @param \Illuminate\Http\Request $request
         </em> @param  \Closure  $next<br><em> @return mixed
</em>/<br>public function handle($request, Closure $next)<br>{<br>// Test for an even vs. odd remote port<br>if (($request-&gt;server-&gt;get(‘REMOTE_PORT’) / 2) % 2 &gt; 0)<br>{<br>throw new \Exception(“WE DON’T LIKE ODD REMOTE PORTS”);<br>}<br><br>return $next($request);<br>}<br><br>}</pre><br></div><br></div>

<h2 id="u5982_u4F55_u5B9A_u4E49MiddleWare"><a href="#u5982_u4F55_u5B9A_u4E49MiddleWare" class="headerlink" title="如何定义MiddleWare"></a>如何定义MiddleWare</h2><p>laravel5提供了两种方法使用中间件，都是在App\Http\Kernel文件中配置：<br>kernel文件中有两个配置选项middleware和routeMiddleware，middleware配置选项将会应用到每个request请求，而routeMiddleware只是针对某些路由适用，这里只是配置了别名，下面会介绍如何使用别名调用中间件。</p>
<blockquote>
<p>大家注意在middleWare中默认启动的选项中有VerifyCsrfToken,就标志了在laravel5之后对每一个post请求都会做csrf处理，具体使用大家参考表单那一章。</p>
<p><pre class="lang:php decode:true">middlewares：</pre></p>
</blockquote>
<p>protected $middleware = [<br>‘Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode’,<br>‘Illuminate\Cookie\Middleware\EncryptCookies’,<br>‘Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse’,<br>‘Illuminate\Session\Middleware\StartSession’,<br>‘Illuminate\View\Middleware\ShareErrorsFromSession’,<br>‘Illuminate\Foundation\Http\Middleware\VerifyCsrfToken’,<br>];<br>routeMiddleware</p>
<p>protected $routeMiddleware = [<br>‘auth’ = ‘App\Http\Middleware\Authenticate’,<br>‘auth.basic’ =&gt; ‘Illuminate\Auth\Middleware\AuthenticateWithBasicAuth’,<br>‘guest’ =&gt; ‘App\Http\Middleware\RedirectIfAuthenticated’,<br>];<br>大家可以根据自己的需求添加middleware或者routeMiddle中，在添加使用时要注意区分两者的区别。<br>大家已经指定middleware是使用handle函数来控制request，那么在laravel4中的beforeFilter和afterFilter在中间件中又是怎样实现的呢？</p>
<div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">…<br>class BeforeMiddleware implements Middleware {<br><br>public function handle($request, Closure $next)<br>{<br>//请求返回之前做些事情<br>return $next($request);<br>}<br><br>}<br>…<br>class AfterMiddleware implements Middleware {<br><br>public function handle($request, Closure $next)<br>{<br>$response = $next($request);<br>            // 请求返回之后做些事情<br>            return $response;<br>}<br><br>}</pre><br></div><br></div><br>大家可以从上例中看出，beforeFilter和afterFilter也是在handle函数中根据$next匿名函数执行的顺序来控制Filter的执行顺序，也是非常好理解的。<br><br>## 使用MiddleWare<br><br>1 在路由中使用（推荐）<br>在Routes.php文件中配置中间件，业务逻辑可以清晰的在路由文件中展现：<br>// Routes.php<br><div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">// 单个路由<br>$router-&gt;get(“/awesome/sauce”, “AwesomeController@sauce”, [‘middleware’ =&gt; ‘auth’]);<br><br>// 路由组<br>$router-&gt;group([‘middleware’ =&gt; ‘auth’], function() {<br>// lots of routes that require auth middleware<br>});</pre><br></div><br></div><br>2 控制器中使用<br><pre class="lang:php decode:true">…<br>use Illuminate\Routing\Controller;<br><br>class AwesomeController extends Controller {<br><br>public function __construct()<br>{<br>$this-&gt;middleware(‘csrf’);<br>            $this-&gt;middleware(‘auth’, [‘only’ =&gt; ‘update’])<br>}<br><br>}</pre><br>3 使用route annotation（路由声明）<br><div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">/<em>*
</em> @Resource(“foobar/photos”)<br><em> @Middleware(“auth”)
</em> @Middleware(“absurd”, except={“update”})<br><em> @Middleware(“csrf”, only={“index”})
</em>/<br>class FoobarPhotosController<br>{}</pre><br></div><br></div><br>Laravel5已经不再支持annotation方法，不建议大家使用，如果独特喜欢此类写法，往下看：<br>路由声明需要配置scans函数：<br>App/Providers/RouteServiceProvider.php<br><div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">public function scans()<br>{<br>return<br>[‘App\Http\Controllers\HomeController’,<br>‘App\Http\Controllers\Auth\AuthController’,<br>‘App\Http\Controllers\Auth\PasswordController’,<br>‘App\Http\Controllers\PagesController’];<br>}</pre><br></div><br></div><br>执行以下命令生成路由规则图：<br><div class="linenums"><br><div class="L0"><br><pre class="lang:php decode:true">php artisan clear-compiled<br>php artisan route:scan</pre><br></div><br></div></div></article></div></section><footer><div class="paginator"><a href="/blog/2015/05/04/laravel5-cloud-file-drivers/" class="prev">上一篇</a><a href="/blog/2015/04/23/the-ten-psychological-of-social-networking-users-blame/" class="next">下一篇</a></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>